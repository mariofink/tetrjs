// Generated by CoffeeScript 1.4.0
(function() {
  var GameScreen, L, O, Screen, Tetromino, gfx, keys, utils,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  utils = {
    now: function() {
      return new Date().getTime();
    },
    snap: function(value, snapSize) {
      return Math.floor(value / snapSize) * snapSize;
    },
    rand: function(min, max) {
      var range;
      if (!(max != null)) {
        max = min;
        min = 0;
      }
      range = max - min;
      return Math.floor((Math.random() * range) + min);
    },
    /*
        The counter function takes a maximum value to count to, and a speed (default is 100ms). Dividing the current time by the speed results in the number of steps that have occurred since JavaScript’s epoch: January 1, 1970. This only becomes useful when we take the modulus of those steps by the maximum value. Now we have a counter that counts to our maximum value, then resets—ad infinitum!
    */

    counter: function(max, speed) {
      if (speed == null) {
        speed = 100;
      }
      return Math.floor(this.now() / speed % max);
    }
  };

  Tetromino = (function() {

    Tetromino.prototype.x = 0;

    Tetromino.prototype.y = 0;

    Tetromino.prototype.currentState = 0;

    Tetromino.prototype.states = [];

    Tetromino.prototype.lastChange = utils.now();

    Tetromino.prototype.lastMove = utils.now();

    Tetromino.prototype.blocks = [];

    Tetromino.prototype.asciiMap = null;

    function Tetromino(x, y) {
      var row;
      this.x = x;
      this.y = y;
      if (this.states.length > 0) {
        this.asciiMap = (function() {
          var _i, _len, _ref, _results;
          _ref = this.states[this.currentState].split("\n");
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            row = _ref[_i];
            _results.push(row.split(""));
          }
          return _results;
        }).call(this);
      }
    }

    Tetromino.prototype.nextState = function() {
      if (utils.now() - this.lastChange < 200) {
        return;
      }
      this.currentState++;
      if (this.currentState > this.states.length - 1) {
        this.currentState = 0;
      }
      this.lastChange = utils.now();
      return this.currentState;
    };

    Tetromino.prototype.prevState = function() {
      if (utils.now() - this.lastChange < 200) {
        return;
      }
      this.currentState--;
      if (this.currentState < 0) {
        this.currentState = this.states.length - 1;
      }
      this.lastChange = utils.now();
      return this.currentState;
    };

    Tetromino.prototype.update = function() {
      var col, moveAllowed, newX, newY, row, x, y, _x, _y;
      if (keys.up) {
        this.nextState();
      }
      _x = this.x;
      _y = this.y;
      if ((keys.left || keys.right || keys.down) && utils.now() - this.lastMove > 200) {
        this.lastMove = utils.now();
        if (keys.left) {
          _x -= 1;
        }
        if (keys.right) {
          _x += 1;
        }
        if (keys.down) {
          _y += 1;
        }
      }
      moveAllowed = true;
      this.map = (function() {
        var _i, _len, _ref, _results;
        _ref = this.asciiMap;
        _results = [];
        for (y = _i = 0, _len = _ref.length; _i < _len; y = ++_i) {
          row = _ref[y];
          _results.push((function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (x = _j = 0, _len1 = row.length; _j < _len1; x = ++_j) {
              col = row[x];
              switch (col) {
                case "#":
                  newX = x + _x;
                  newY = y + _y;
                  if (newX >= 10 || newX < 0 || newY >= 18) {
                    _results1.push(moveAllowed = false);
                  } else {
                    _results1.push(void 0);
                  }
                  break;
                default:
                  _results1.push(void 0);
              }
            }
            return _results1;
          })());
        }
        return _results;
      }).call(this);
      if (moveAllowed) {
        this.x = _x;
        return this.y = _y;
      }
    };

    Tetromino.prototype.render = function(gfx) {
      var col, row, x, y;
      return this.map = (function() {
        var _i, _len, _ref, _results;
        _ref = this.asciiMap;
        _results = [];
        for (y = _i = 0, _len = _ref.length; _i < _len; y = ++_i) {
          row = _ref[y];
          _results.push((function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (x = _j = 0, _len1 = row.length; _j < _len1; x = ++_j) {
              col = row[x];
              switch (col) {
                case "#":
                  _results1.push(gfx.drawBlock((gfx.tileSize * x) + (this.x * gfx.tileSize), (gfx.tileSize * y) + (this.y * gfx.tileSize)));
                  break;
                default:
                  _results1.push(void 0);
              }
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }).call(this);
    };

    return Tetromino;

  })();

  L = (function(_super) {

    __extends(L, _super);

    function L(x, y) {
      this.x = x;
      this.y = y;
      this.currentState = 0;
      this.states = ["#...\n#...\n##..\n....", "..#.\n###.\n....\n....", "##..\n.#..\n.#..\n....", "###.\n#...\n....\n...."];
      L.__super__.constructor.apply(this, arguments);
    }

    return L;

  })(Tetromino);

  O = (function(_super) {

    __extends(O, _super);

    function O() {
      this.currentState = 0;
      this.states = ["##..\n##..\n....\n...."];
    }

    return O;

  })(Tetromino);

  Screen = (function() {

    function Screen() {}

    Screen.prototype.update = function() {};

    Screen.prototype.render = function(gfx) {};

    return Screen;

  })();

  GameScreen = (function(_super) {

    __extends(GameScreen, _super);

    GameScreen.prototype.levelNumber = 0;

    function GameScreen() {
      this.tetromino = new L(3, 3);
    }

    GameScreen.prototype.update = function() {
      return this.tetromino.update();
    };

    GameScreen.prototype.render = function(gfx) {
      gfx.ctx.save();
      this.tetromino.render(gfx);
      return gfx.ctx.restore();
    };

    return GameScreen;

  })(Screen);

  keys = {
    up: false,
    down: false,
    left: false,
    right: false,
    fire: false,
    space: false,
    reset: function() {
      return this.up = this.down = this.left = this.right = this.fire = false;
    },
    trigger: function(keyCode, isDown) {
      switch (keyCode) {
        case 32:
          return this.space = isDown;
        case 37:
          return this.left = isDown;
        case 39:
          return this.right = isDown;
        case 38:
          return this.up = isDown;
        case 40:
          return this.down = isDown;
      }
    }
  };

  $(document).keydown(function(e) {
    return keys.trigger(e.keyCode, true);
  });

  $(document).keyup(function(e) {
    return keys.trigger(e.keyCode, false);
  });

  gfx = {
    tileSize: 24,
    dimension: {
      x: 10,
      y: 18
    },
    init: function() {
      var canvas;
      console.log("init");
      canvas = $("#game")[0];
      this.ctx = canvas != null ? typeof canvas.getContext === "function" ? canvas.getContext("2d") : void 0 : void 0;
      if (!this.ctx) {
        return false;
      }
      canvas.width = this.dimension.x * this.tileSize;
      canvas.height = this.dimension.y * this.tileSize;
      this.w = canvas.width;
      this.h = canvas.height;
      return true;
    },
    drawBlock: function(x, y) {
      this.ctx.fillStyle = "#bada55";
      return this.ctx.fillRect(x, y, this.tileSize, this.tileSize);
    },
    clear: function() {
      return this.ctx.clearRect(0, 0, this.w, this.h);
    }
  };

  this.tetrjs = {
    screen: null,
    dialog: null,
    running: false,
    init: function() {
      if (!gfx.init()) {
        alert("Sorry, no canvas");
        return;
      }
      return this.reset();
    },
    start: function() {
      return this.running = true;
    },
    stop: function() {
      return this.running = false;
    },
    reset: function() {
      this.screen = new GameScreen();
      if (!this.running) {
        this.start();
        return this.tick();
      }
    },
    tick: function() {
      var _this = this;
      if (!this.running) {
        return;
      }
      gfx.clear();
      this.update();
      this.render();
      return window.requestAnimationFrame((function() {
        return _this.tick();
      }));
    },
    update: function() {
      if (this.dialog != null) {
        return this.dialog.update();
      } else {
        return this.screen.update();
      }
    },
    render: function() {
      return this.screen.render(gfx);
    }
  };

  $(document).ready(function() {
    return tetrjs.init();
  });

}).call(this);
